{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Linnaeus Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. An algorithm is specified by defining variables, parameters, functions, oracles, and update equations. Linnaeus can check algorithm relations including Oracle equivalence (algorithms generate identical sequence of oracle calls) Linear state transform (states are identical up to a linear map) Permutation (shift equivalence, algorithms generate identical sequence of oracle calls up to a shift) Repetition (one algorithm repeats the updates of another algorithm) Conjugation (algorithm calls conjugate function oracles, i.e. Fenchel conjugate) Duality (conjugation on all algorithm oracles) For more information about algorithm equivalence and relations, see our paper . Installation To install using pip, run: pip install git+https://github.com/udellgroup/Linnaeus_software To install from source, first make sure setuptools has been installed. Then, Clone the Linnaeus git repo. Navigate to the top-level of the directory and run: python setup.py install To test the installation with nose2, first make sure nose2 has been installed. Then run: nose2 linnaeus The requirements are: SymPy = 1.6.2 NumPy = 1.16 SciPy = 1.2.1 Python 3.x Algorithm library Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method Alternating direction method of multipliers (ADMM) Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Home"},{"location":"#linnaeus","text":"Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. An algorithm is specified by defining variables, parameters, functions, oracles, and update equations. Linnaeus can check algorithm relations including Oracle equivalence (algorithms generate identical sequence of oracle calls) Linear state transform (states are identical up to a linear map) Permutation (shift equivalence, algorithms generate identical sequence of oracle calls up to a shift) Repetition (one algorithm repeats the updates of another algorithm) Conjugation (algorithm calls conjugate function oracles, i.e. Fenchel conjugate) Duality (conjugation on all algorithm oracles) For more information about algorithm equivalence and relations, see our paper .","title":"Linnaeus"},{"location":"#installation","text":"To install using pip, run: pip install git+https://github.com/udellgroup/Linnaeus_software To install from source, first make sure setuptools has been installed. Then, Clone the Linnaeus git repo. Navigate to the top-level of the directory and run: python setup.py install To test the installation with nose2, first make sure nose2 has been installed. Then run: nose2 linnaeus The requirements are: SymPy = 1.6.2 NumPy = 1.16 SciPy = 1.2.1 Python 3.x","title":"Installation"},{"location":"#algorithm-library","text":"Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method Alternating direction method of multipliers (ADMM) Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Algorithm library"},{"location":"basic_types/","text":"Basic Types The major building block is called an algorithm. An algorithm is defined with variables, parameters, functions, oracles, and update equations. All the expressions in Linnaeus are defined symbolically using SymPy. Algorithms Algorithm is defined using keyword Algorithm along with the name of the algorithm. The following code defines an Algorithm as new_algo named my new algorithm . new_algo = Algorithm( my new algorithm ) Expressions such as variables, parameters, functions, oracles, and update equations are all attributes to an algorithm object. An algorithm must be defined before other expressions are defined and added to it. Variables Variables are algorithm states. They are declared and added to an algorithm using syntax add_var along with the names of the variables. In the following example, we add variables x1 and x2 to new_algo . x1, x2 = new_algo.add_var( x1 , x2 ) Each algorithm state (each variable) must be updated at each iteration. The updated variables can be accessed by syntax update . Here we access the updated x1 with x1u and updated x2 with x2u in the following code. x1u, x2u = new_algo.update(x1, x2) Parameters Parameters of an algorithm can be declared as scalar (commutative) or vector or matrix (noncommutative). Parameters are declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or matrix, the argument commutative should be set as False . The default setting of argument commutative is True . There is no need to specialize the dimensions of vectors or matrices, since they are symbolic. The following code shows how to add scalar t and matrix L to new_algo . t = new_algo.add_parameter( t ) L = new_algo.add_parameter( L , commutative = False) Warning for noncommutative parameters Due to limited support for noncommutative symbol calculation in SymPy, Linnaeus may not correctly parse extremely complex algorithms including noncommutative symbols. It is also possible that Linnaeus may not get the parameter mapping for noncommutative symbols (matrices or vectors) when detecting equivalence for such algorithms. In such cases, we recommand users to declare all the parameters as commutative symbols! Oracles Linnaeus provides two approaches to declare and add oracles to an algorithm. Black-box approach The black-box approach is to define oracles as black boxes. When parsing the algorithm, the system treats each oracle as a distinct entity unrelated to any other oracle. An oracle declared using syntax add_oracle uses the black-box approach For example, we declare oracles gradient of f and proximal operator of g with the following code. gradf = new_algo.add_oracle( gradf ) proxg = new_algo.add_oracle( proxg ) Functional approach The functional approach is to define oracles in terms of the (sub)gradient of a function. When parsing an algorithm, all the oracles will be decomposed into (sub)gradients. This approach is important to allow detection algorithm conjugation. This example shows the details. With the functional approach, functions must be defined and added to the algorithm using syntax add_function before defining oracles. The following example shows to define function f and add it to new_algo f = new_algo.add_function( f ) Linnaeus provides four types of oracles that can be decomposed into (sub)gradients, Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin import linnaeus as lin # gradient of f with respect to x1 lin.grad(f)(x1) # proximal operator of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x)) To use the projection oracle, a set must be declared in advance with syntax add_set . Update equations Update equations define the iterative procedures of an algorithm. All the update equations have common structure that an updated variable equals an expression of variables, parameters, and oracles. An update equation is defined with syntax add_update . new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) The update equations in the above example are interpreted as Or interpreted as equalities, By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is considered as the updated x1 , as the x1^+ in the second equality interpretation. For some cases, we can change the default setting by syntax set_auto , such as new_algo.set_auto(False) new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) Under this setting, we have a different interpretation of the update equations, Warning! To avoid overlap and misleading in expressions, it is highly recommanded that each algorithm should have its own variables, parameters, etc, and those expressions should only be used within this algorithm! For example, algo1 = Algorithm( my first algorithm ) x1, x2 = algo1.add_var( x1 , x2 ) t, h = algo1.add_parameter( t , h ) algo1.add_update(x1, x2 - t*x2) algo1.add_update(x2, x1 - h*x2) algo2 = Algorithm( my second algorithm ) x1, x2 = algo2.add_var( x1 , x2 ) t, h = algo2.add_parameter( t , h ) algo2.add_update(x1, x2 - h*x1) algo2.add_update(x2, x1 - t*x2) Variables x1 and x2 , parameters t and h are declared within the first algorithm algo1 . They should only be used within algo1 , such as the update equations of it. For the second algorithm algo2 , if we still want to use variables x1 , x2 , and parameters t , h , they should be declared again within algo2 .","title":"Basic Types"},{"location":"basic_types/#basic-types","text":"The major building block is called an algorithm. An algorithm is defined with variables, parameters, functions, oracles, and update equations. All the expressions in Linnaeus are defined symbolically using SymPy.","title":"Basic Types"},{"location":"basic_types/#algorithms","text":"Algorithm is defined using keyword Algorithm along with the name of the algorithm. The following code defines an Algorithm as new_algo named my new algorithm . new_algo = Algorithm( my new algorithm ) Expressions such as variables, parameters, functions, oracles, and update equations are all attributes to an algorithm object. An algorithm must be defined before other expressions are defined and added to it.","title":"Algorithms"},{"location":"basic_types/#variables","text":"Variables are algorithm states. They are declared and added to an algorithm using syntax add_var along with the names of the variables. In the following example, we add variables x1 and x2 to new_algo . x1, x2 = new_algo.add_var( x1 , x2 ) Each algorithm state (each variable) must be updated at each iteration. The updated variables can be accessed by syntax update . Here we access the updated x1 with x1u and updated x2 with x2u in the following code. x1u, x2u = new_algo.update(x1, x2)","title":"Variables"},{"location":"basic_types/#parameters","text":"Parameters of an algorithm can be declared as scalar (commutative) or vector or matrix (noncommutative). Parameters are declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or matrix, the argument commutative should be set as False . The default setting of argument commutative is True . There is no need to specialize the dimensions of vectors or matrices, since they are symbolic. The following code shows how to add scalar t and matrix L to new_algo . t = new_algo.add_parameter( t ) L = new_algo.add_parameter( L , commutative = False)","title":"Parameters"},{"location":"basic_types/#warning-for-noncommutative-parameters","text":"Due to limited support for noncommutative symbol calculation in SymPy, Linnaeus may not correctly parse extremely complex algorithms including noncommutative symbols. It is also possible that Linnaeus may not get the parameter mapping for noncommutative symbols (matrices or vectors) when detecting equivalence for such algorithms. In such cases, we recommand users to declare all the parameters as commutative symbols!","title":"Warning for noncommutative parameters"},{"location":"basic_types/#oracles","text":"Linnaeus provides two approaches to declare and add oracles to an algorithm.","title":"Oracles"},{"location":"basic_types/#black-box-approach","text":"The black-box approach is to define oracles as black boxes. When parsing the algorithm, the system treats each oracle as a distinct entity unrelated to any other oracle. An oracle declared using syntax add_oracle uses the black-box approach For example, we declare oracles gradient of f and proximal operator of g with the following code. gradf = new_algo.add_oracle( gradf ) proxg = new_algo.add_oracle( proxg )","title":"Black-box approach"},{"location":"basic_types/#functional-approach","text":"The functional approach is to define oracles in terms of the (sub)gradient of a function. When parsing an algorithm, all the oracles will be decomposed into (sub)gradients. This approach is important to allow detection algorithm conjugation. This example shows the details. With the functional approach, functions must be defined and added to the algorithm using syntax add_function before defining oracles. The following example shows to define function f and add it to new_algo f = new_algo.add_function( f ) Linnaeus provides four types of oracles that can be decomposed into (sub)gradients, Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin import linnaeus as lin # gradient of f with respect to x1 lin.grad(f)(x1) # proximal operator of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x)) To use the projection oracle, a set must be declared in advance with syntax add_set .","title":"Functional approach"},{"location":"basic_types/#update-equations","text":"Update equations define the iterative procedures of an algorithm. All the update equations have common structure that an updated variable equals an expression of variables, parameters, and oracles. An update equation is defined with syntax add_update . new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) The update equations in the above example are interpreted as Or interpreted as equalities, By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is considered as the updated x1 , as the x1^+ in the second equality interpretation. For some cases, we can change the default setting by syntax set_auto , such as new_algo.set_auto(False) new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) Under this setting, we have a different interpretation of the update equations,","title":"Update equations"},{"location":"basic_types/#warning","text":"To avoid overlap and misleading in expressions, it is highly recommanded that each algorithm should have its own variables, parameters, etc, and those expressions should only be used within this algorithm! For example, algo1 = Algorithm( my first algorithm ) x1, x2 = algo1.add_var( x1 , x2 ) t, h = algo1.add_parameter( t , h ) algo1.add_update(x1, x2 - t*x2) algo1.add_update(x2, x1 - h*x2) algo2 = Algorithm( my second algorithm ) x1, x2 = algo2.add_var( x1 , x2 ) t, h = algo2.add_parameter( t , h ) algo2.add_update(x1, x2 - h*x1) algo2.add_update(x2, x1 - t*x2) Variables x1 and x2 , parameters t and h are declared within the first algorithm algo1 . They should only be used within algo1 , such as the update equations of it. For the second algorithm algo2 , if we still want to use variables x1 , x2 , and parameters t , h , they should be declared again within algo2 .","title":"Warning!"},{"location":"citation/","text":"Citing Linnaeus If you use Linnaeus for published work, we encourage you to cite the software. Use the following BibTeX citation: @misc{linnaeus, title={An automatic system to detect equivalence between iterative algorithms}, author={Shipu Zhao and Laurent Lessard and Madeleine Udell}, year={2021}, eprint={2105.04684}, archivePrefix={arXiv}, primaryClass={math.OC} }","title":"Citing Linnaeus"},{"location":"citation/#citing-linnaeus","text":"If you use Linnaeus for published work, we encourage you to cite the software. Use the following BibTeX citation: @misc{linnaeus, title={An automatic system to detect equivalence between iterative algorithms}, author={Shipu Zhao and Laurent Lessard and Madeleine Udell}, year={2021}, eprint={2105.04684}, archivePrefix={arXiv}, primaryClass={math.OC} }","title":"Citing Linnaeus"},{"location":"contributing/","text":"Contributing Linnaeus is an open-source project open to any academic or commercial applications. Contributions are welcome as GitHub pull requests in any part of the project. A## Add new algorithm to the library If you believe that an algorithm is important and not included in the library of Linnaeus, you are welcome to submit a GitHub pull request named as Adding new algorithm XXX , where XXX is the name of the new algorithm. To add a new algorithm, you need to edit the algorithms_library.py file under linnaeus/ directory as the following Chambolle-Pock method example. New algorithm should be added at the end of the file. The procedures to load a new algorithm are generally the same as the steps to input and parse an algorithm in Linnaeus as stated in quick tutorial . The following code shows how to load the Chambolle-Pock method to the library. # define name Chambolle-Pock method and name string Cp Cp = Algorithm( Chambolle-Pock method , Cp ) # define functions f, g = Cp.add_function( f , g ) # define parameters sigma, tau, theta = Cp.add_parameter( sigma , tau , theta ) # define varaibles x1, x2, x3, x4 = Cp.add_var( x1 , x2 , x3 , x4 ) # define update equations Cp.add_update(x1, prox(f, tau)(x3 - tau * x4)) Cp.add_update(x2, prox(g, sigma)(x4 + sigma * (2 * x1 - x3))) Cp.add_update(x3, x3 + theta * (x1 - x3)) Cp.add_update(x4, x4 + theta * (x2 - x4)) # parse the algorithm without showing the update equations Cp._parse() # add latex representation of Chambolle-Pock method Cp.equation_string = r x_1^+ = \\text{prox}_{\\tau f} (x_3 - \\tau x_4) \\\\ x_2^+ = \\text{prox}_{\\sigma g^*} (x_4 + \\sigma (2x_1^+ - x_3)) \\\\ x_3^+ = x_3 + \\theta (x_1^{+} - x_3) \\\\ x_4^+ = x_4 + \\theta (x_2^+ - x_4) # load the Chambolle-Pock method to library algo_library.load_algo(Cp) To avoid overlap in algorithms, we highly recommand you to check equivalence and relations between the new algorithm and existing algorithms in the library to ensure uniqueness. Function analyze() can be used to detect possible connections between the new algorithm and all existing algorithms in the library.","title":"Contributing"},{"location":"contributing/#contributing","text":"Linnaeus is an open-source project open to any academic or commercial applications. Contributions are welcome as GitHub pull requests in any part of the project. A## Add new algorithm to the library If you believe that an algorithm is important and not included in the library of Linnaeus, you are welcome to submit a GitHub pull request named as Adding new algorithm XXX , where XXX is the name of the new algorithm. To add a new algorithm, you need to edit the algorithms_library.py file under linnaeus/ directory as the following Chambolle-Pock method example. New algorithm should be added at the end of the file. The procedures to load a new algorithm are generally the same as the steps to input and parse an algorithm in Linnaeus as stated in quick tutorial . The following code shows how to load the Chambolle-Pock method to the library. # define name Chambolle-Pock method and name string Cp Cp = Algorithm( Chambolle-Pock method , Cp ) # define functions f, g = Cp.add_function( f , g ) # define parameters sigma, tau, theta = Cp.add_parameter( sigma , tau , theta ) # define varaibles x1, x2, x3, x4 = Cp.add_var( x1 , x2 , x3 , x4 ) # define update equations Cp.add_update(x1, prox(f, tau)(x3 - tau * x4)) Cp.add_update(x2, prox(g, sigma)(x4 + sigma * (2 * x1 - x3))) Cp.add_update(x3, x3 + theta * (x1 - x3)) Cp.add_update(x4, x4 + theta * (x2 - x4)) # parse the algorithm without showing the update equations Cp._parse() # add latex representation of Chambolle-Pock method Cp.equation_string = r x_1^+ = \\text{prox}_{\\tau f} (x_3 - \\tau x_4) \\\\ x_2^+ = \\text{prox}_{\\sigma g^*} (x_4 + \\sigma (2x_1^+ - x_3)) \\\\ x_3^+ = x_3 + \\theta (x_1^{+} - x_3) \\\\ x_4^+ = x_4 + \\theta (x_2^+ - x_4) # load the Chambolle-Pock method to library algo_library.load_algo(Cp) To avoid overlap in algorithms, we highly recommand you to check equivalence and relations between the new algorithm and existing algorithms in the library to ensure uniqueness. Function analyze() can be used to detect possible connections between the new algorithm and all existing algorithms in the library.","title":"Contributing"},{"location":"detection/","text":"Equivalence Detection Parse an algorithm Suppose an algorithm is already defined and variables, parameters, oracles, and update equations are added to the algorithm, the next step is to parse the algorithm. Syntax parse is used to translate the input algorithm into a canonical form (transfer function) and use the canonical form to perform subsequent analysis such as equivalence detection. When parsing an algorithm, the update equations are provided by the system. With example of gradient descent algorithm, The following code defines the gradient descent algorithm as algo3 and parses it into canonical form. import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( gradient descent algorithm ) x1 = algo3.add_var( x1 ) t = algo3.add_parameter( t ) gradf = algo3.add_oracle( gradf ) algo3.add_update(x1, x1 - t*gradf(x1)) algo3.parse() Detection Linnaeus provides a set of functions to check algorithm equivalence and relations. Oracle equivalence and linear transform, is_equivalent() and test_equivalence() Permutation, is_permutation() and test_permutation() Repetition, is_repetition() and test_repetition() Conjugation, is_conjugation() and test_conjugation() Duality, is_duality() and test_duality() Here is a brief description of algorithm equivalence and relations. For more details, see our paper . These functions take two arguments, the first one is the target algorithm to parse and the second is the reference algorithm or a list of reference algorithms. For each type of algorithm equivalence or relations, the is_ function returns boolean or a list of boolean, simply indicating whether the input algorithm and the reference algorithm are equivalent/related or not. The test_ function returns more details. Specifically, if two algorithms are equivalent/related only when the parameters satisfy a certain condition, the test_ function will return the condition. For illustration, we define the triple momentum algorithm as algo4 and check oracle equivalence between algo3 and algo4 . algo4 = Algorithm( triple momentum algorithm ) x1, x2, x3 = algo4.add_var( x1 , x2 , x3 ) alpha, beta, eta = algo4.add_parameter( alpha , beta , eta ) gradf = algo4.add_oracle( gradf ) algo4.add_update(x3, x1) algo4.add_update(x1, (1 + beta)*x1 - beta*x2 - alpha*gradf((1 + eta)*x1 - eta*x2)) algo4.add_update(x2, x3) algo4.parse() lin.is_equivalent(algo3, algo4) The system returns True To return the conditions for parameters that yield equivalence, we can use the test_equivalent() function as follows. lin.test_equivalent(algo3, algo4) Double check Under very occasional cases, Linnaeus may not be able to identify equivalence and relations between algorithms. This is due to limitations of SymPy equation solver. In such cases, we recommand users to do double check with the detection functions while exchange the input algorithm and the reference algorithm. For example, the following code shows to do double check for equivalence between algo3 and algo4 . lin.is_equivalent(algo3, algo4) # exchange the input algorithm and the reference algorithm lin.is_equivalent(algo4, algo3) Multiple relations It is possible that algorithms are related with multiple relations. In such cases, one algorithm can be transformed into another by sequentially performing multiple aforementioned transformations. Here is an example to detect conjugation and permutation between Douglas-Rachford splitting and ADMM. In this example, Douglas-Rachford splitting can be transformed to ADMM, by performing conjugation and permutation. (Since conjugation and permutation commute, the sequence does not matter.) Linnaeus provides two functions is_conjugate_permutation() and test_conjugate_permutation() to detect conjugation and permutation together. The input and output for these functions are the same as the aforementioned detection functions. LaTeX support We recommand users to use an IPython console that LaTeX is installed to check the parameter maps returned by the test_ functions. An IPython notebook with LaTeX support is also recommanded. Access state-space realization and transfer function State-space realization Function get_ss(verbose) returns the state-space realization of an algorithm. If verbose is False , it will return a big matrix containing state-space matrices A, B, C, and D. If verbose is True , it will explicitly indicate the A, B, C, and D matrices. The default setting of verbose is False . The following example shows to get the state-space realization of the triple momentum algorithm, algo4 . algo4.get_ss() algo4.get_ss(verbose = True) Specifically, function get_canonical_ss(ss_type, verbose) returns the canonical form of the state-space realization. If ss_type is 'c' , it will return the controllable canonical form; and if ss_type is 'o' , it will return the observable canonical form. The default setting is 'c' . More details about controlable and observable canonical forms can be found here . verbose is the same as function get_ss() . The following example shows to get the observable canonical form of state-space realization of the triple momentum algorithm, algo4 . algo4.get_canonical_ss(ss_type = 'o', verbose = True) Transfer function Function get_tf() returns the transfer function of an algorithm. The following code shows to get the transfer function of the triple momentum algorithm, algo4 . algo4.get_tf() Transform an algorithm To detect complex relations, Linnaeus provides a set of functions to transform an algorithm. permute(step) , returns a permutation of an algorithm with specific steps set by argument step . The default setting of step is 0, which returns the one-step permutation. step should be an integer and less than the total oracle number of the algorithm. conjugate(conjugate_oracle) , returns the conjugate of an algorithm with respect to the specific oracle set by argument conjugate_oracle . The default setting of conjugate_oracle is 0, which returns the conjugate with respect to the first oracle. conjugate_oracle should be an integer and within the set of oracle indices of the algorithm. If an algorithm contains n oracles, its set of oracle indices is [0, ..., n - 1] . dual() , returns the conjugate of an algorithm with respect to all the oracles. repeat(times) , returns a repetition of an algorithm that repeats the algorithm with times of times. The default setting of times is 2, which repeats the algorithm twice. times should be an positive integer. The following code transforms new_algo in different ways. new_algo.permute() new_algo.conjugate(1) new_algo.dual() new_algo.repeat(3) For example, we can get the state-space realization for the permutation of new_algo as follows, new_algo.permute().get_ss()","title":"Detection"},{"location":"detection/#equivalence-detection","text":"","title":"Equivalence Detection"},{"location":"detection/#parse-an-algorithm","text":"Suppose an algorithm is already defined and variables, parameters, oracles, and update equations are added to the algorithm, the next step is to parse the algorithm. Syntax parse is used to translate the input algorithm into a canonical form (transfer function) and use the canonical form to perform subsequent analysis such as equivalence detection. When parsing an algorithm, the update equations are provided by the system. With example of gradient descent algorithm, The following code defines the gradient descent algorithm as algo3 and parses it into canonical form. import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( gradient descent algorithm ) x1 = algo3.add_var( x1 ) t = algo3.add_parameter( t ) gradf = algo3.add_oracle( gradf ) algo3.add_update(x1, x1 - t*gradf(x1)) algo3.parse()","title":"Parse an algorithm"},{"location":"detection/#detection","text":"Linnaeus provides a set of functions to check algorithm equivalence and relations. Oracle equivalence and linear transform, is_equivalent() and test_equivalence() Permutation, is_permutation() and test_permutation() Repetition, is_repetition() and test_repetition() Conjugation, is_conjugation() and test_conjugation() Duality, is_duality() and test_duality() Here is a brief description of algorithm equivalence and relations. For more details, see our paper . These functions take two arguments, the first one is the target algorithm to parse and the second is the reference algorithm or a list of reference algorithms. For each type of algorithm equivalence or relations, the is_ function returns boolean or a list of boolean, simply indicating whether the input algorithm and the reference algorithm are equivalent/related or not. The test_ function returns more details. Specifically, if two algorithms are equivalent/related only when the parameters satisfy a certain condition, the test_ function will return the condition. For illustration, we define the triple momentum algorithm as algo4 and check oracle equivalence between algo3 and algo4 . algo4 = Algorithm( triple momentum algorithm ) x1, x2, x3 = algo4.add_var( x1 , x2 , x3 ) alpha, beta, eta = algo4.add_parameter( alpha , beta , eta ) gradf = algo4.add_oracle( gradf ) algo4.add_update(x3, x1) algo4.add_update(x1, (1 + beta)*x1 - beta*x2 - alpha*gradf((1 + eta)*x1 - eta*x2)) algo4.add_update(x2, x3) algo4.parse() lin.is_equivalent(algo3, algo4) The system returns True To return the conditions for parameters that yield equivalence, we can use the test_equivalent() function as follows. lin.test_equivalent(algo3, algo4)","title":"Detection"},{"location":"detection/#double-check","text":"Under very occasional cases, Linnaeus may not be able to identify equivalence and relations between algorithms. This is due to limitations of SymPy equation solver. In such cases, we recommand users to do double check with the detection functions while exchange the input algorithm and the reference algorithm. For example, the following code shows to do double check for equivalence between algo3 and algo4 . lin.is_equivalent(algo3, algo4) # exchange the input algorithm and the reference algorithm lin.is_equivalent(algo4, algo3)","title":"Double check"},{"location":"detection/#multiple-relations","text":"It is possible that algorithms are related with multiple relations. In such cases, one algorithm can be transformed into another by sequentially performing multiple aforementioned transformations. Here is an example to detect conjugation and permutation between Douglas-Rachford splitting and ADMM. In this example, Douglas-Rachford splitting can be transformed to ADMM, by performing conjugation and permutation. (Since conjugation and permutation commute, the sequence does not matter.) Linnaeus provides two functions is_conjugate_permutation() and test_conjugate_permutation() to detect conjugation and permutation together. The input and output for these functions are the same as the aforementioned detection functions.","title":"Multiple relations"},{"location":"detection/#latex-support","text":"We recommand users to use an IPython console that LaTeX is installed to check the parameter maps returned by the test_ functions. An IPython notebook with LaTeX support is also recommanded.","title":"LaTeX support"},{"location":"detection/#access-state-space-realization-and-transfer-function","text":"","title":"Access state-space realization and transfer function"},{"location":"detection/#state-space-realization","text":"Function get_ss(verbose) returns the state-space realization of an algorithm. If verbose is False , it will return a big matrix containing state-space matrices A, B, C, and D. If verbose is True , it will explicitly indicate the A, B, C, and D matrices. The default setting of verbose is False . The following example shows to get the state-space realization of the triple momentum algorithm, algo4 . algo4.get_ss() algo4.get_ss(verbose = True) Specifically, function get_canonical_ss(ss_type, verbose) returns the canonical form of the state-space realization. If ss_type is 'c' , it will return the controllable canonical form; and if ss_type is 'o' , it will return the observable canonical form. The default setting is 'c' . More details about controlable and observable canonical forms can be found here . verbose is the same as function get_ss() . The following example shows to get the observable canonical form of state-space realization of the triple momentum algorithm, algo4 . algo4.get_canonical_ss(ss_type = 'o', verbose = True)","title":"State-space realization"},{"location":"detection/#transfer-function","text":"Function get_tf() returns the transfer function of an algorithm. The following code shows to get the transfer function of the triple momentum algorithm, algo4 . algo4.get_tf()","title":"Transfer function"},{"location":"detection/#transform-an-algorithm","text":"To detect complex relations, Linnaeus provides a set of functions to transform an algorithm. permute(step) , returns a permutation of an algorithm with specific steps set by argument step . The default setting of step is 0, which returns the one-step permutation. step should be an integer and less than the total oracle number of the algorithm. conjugate(conjugate_oracle) , returns the conjugate of an algorithm with respect to the specific oracle set by argument conjugate_oracle . The default setting of conjugate_oracle is 0, which returns the conjugate with respect to the first oracle. conjugate_oracle should be an integer and within the set of oracle indices of the algorithm. If an algorithm contains n oracles, its set of oracle indices is [0, ..., n - 1] . dual() , returns the conjugate of an algorithm with respect to all the oracles. repeat(times) , returns a repetition of an algorithm that repeats the algorithm with times of times. The default setting of times is 2, which repeats the algorithm twice. times should be an positive integer. The following code transforms new_algo in different ways. new_algo.permute() new_algo.conjugate(1) new_algo.dual() new_algo.repeat(3) For example, we can get the state-space realization for the permutation of new_algo as follows, new_algo.permute().get_ss()","title":"Transform an algorithm"},{"location":"examples/","text":"Examples Check permutation algo5 algo6 import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) algo5.add_update(x1, proxf(x3)) algo5.add_update(x2, proxg(2*x1 - x3)) algo5.add_update(x3, x3 + x2 - x1) algo6 = Algorithm( algo6 ) xi1, xi2 = algo6.add_var( xi1 , xi2 ) proxf, proxg = algo6.add_oracle( proxf , proxg ) algo6.add_update(xi1, proxg(-xi1 + 2*xi2) + xi1 - xi2) algo6.add_update(xi2, proxf(xi1)) algo5.parse() algo6.parse() lin.is_permutation(algo5, algo6) System returns True Check repetition algo7 algo8 algo7 = Algorithm( algo7 ) t = algo7.add_parameter( t ) x1 = algo7.add_var( x1 ) f = algo7.add_function( f ) algo7.add_update(x1, x1 - t*lin.grad(f)(x1)) algo8 = Algorithm( algo8 ) xi1, xi2 = algo8.add_var( xi1 , xi2 ) t = algo8.add_parameter( t ) f = algo8.add_function( f ) algo8.add_update(xi2, xi1 - t*lin.grad(f)(xi1)) algo8.add_update(xi1, xi2 - t*lin.grad(f)(xi2)) algo7.parse() algo8.parse() lin.is_repetition(algo7, algo8) System returns True Check conjugation and permutation (Douglas-Rachford splitting and ADMM) For problem, Douglas-Rachford splitting ADMM DR = Algorithm( Douglas-Rachford splitting ) x1, x2, x3 = DR.add_var( x1 , x2 , x3 ) t = DR.add_parameter( t ) f, g = DR.add_function( f , g ) DR.add_update(x1, lin.prox(f, t)(x3)) DR.add_update(x2, lin.prox(g, t)(2*x1 - x3)) DR.add_update(x3, x3 + x2 - x1) ADMM = Algorithm( ADMM ) f, g = ADMM.add_function( f , g ) rho = ADMM.add_parameter( rho ) xi1, xi2, xi3 = ADMM.add_var( xi1 , xi2 , xi3 ) ADMM.add_update(xi1, lin.argmin(xi1, g(xi1) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi2, lin.argmin(xi2, f(xi2) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi3, xi3 + xi1 + xi2) DR.parse() ADMM.parse() # check conjugation and permutation lin.test_conjugate_permutation(DR, ADMM) Check conjugation (Douglas-Rachdford splitting and Chambolle-Pock method) Chambolle-Pock method CP = Algorithm( Chambolle-Pock method ) f, g = CP.add_function( f , g ) x1, x2, x3 = CP.add_var( x1 , x2 , x3 ) tau, sigma = CP.add_parameter( tau , sigma ) CP.add_update(x3, x1) CP.add_update(x1, lin.prox(f, tau)(x1 - tau*x2)) CP.add_update(x2, lin.prox(g, sigma)(x2 + sigma*(2*x1 - x3))) CP.parse() lin.test_conjugation(DR, CP)","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#check-permutation","text":"algo5 algo6 import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) algo5.add_update(x1, proxf(x3)) algo5.add_update(x2, proxg(2*x1 - x3)) algo5.add_update(x3, x3 + x2 - x1) algo6 = Algorithm( algo6 ) xi1, xi2 = algo6.add_var( xi1 , xi2 ) proxf, proxg = algo6.add_oracle( proxf , proxg ) algo6.add_update(xi1, proxg(-xi1 + 2*xi2) + xi1 - xi2) algo6.add_update(xi2, proxf(xi1)) algo5.parse() algo6.parse() lin.is_permutation(algo5, algo6) System returns True","title":"Check permutation"},{"location":"examples/#check-repetition","text":"algo7 algo8 algo7 = Algorithm( algo7 ) t = algo7.add_parameter( t ) x1 = algo7.add_var( x1 ) f = algo7.add_function( f ) algo7.add_update(x1, x1 - t*lin.grad(f)(x1)) algo8 = Algorithm( algo8 ) xi1, xi2 = algo8.add_var( xi1 , xi2 ) t = algo8.add_parameter( t ) f = algo8.add_function( f ) algo8.add_update(xi2, xi1 - t*lin.grad(f)(xi1)) algo8.add_update(xi1, xi2 - t*lin.grad(f)(xi2)) algo7.parse() algo8.parse() lin.is_repetition(algo7, algo8) System returns True","title":"Check repetition"},{"location":"examples/#check-conjugation-and-permutation-douglas-rachford-splitting-and-admm","text":"For problem, Douglas-Rachford splitting ADMM DR = Algorithm( Douglas-Rachford splitting ) x1, x2, x3 = DR.add_var( x1 , x2 , x3 ) t = DR.add_parameter( t ) f, g = DR.add_function( f , g ) DR.add_update(x1, lin.prox(f, t)(x3)) DR.add_update(x2, lin.prox(g, t)(2*x1 - x3)) DR.add_update(x3, x3 + x2 - x1) ADMM = Algorithm( ADMM ) f, g = ADMM.add_function( f , g ) rho = ADMM.add_parameter( rho ) xi1, xi2, xi3 = ADMM.add_var( xi1 , xi2 , xi3 ) ADMM.add_update(xi1, lin.argmin(xi1, g(xi1) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi2, lin.argmin(xi2, f(xi2) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi3, xi3 + xi1 + xi2) DR.parse() ADMM.parse() # check conjugation and permutation lin.test_conjugate_permutation(DR, ADMM)","title":"Check conjugation and permutation (Douglas-Rachford splitting and ADMM)"},{"location":"examples/#check-conjugation-douglas-rachdford-splitting-and-chambolle-pock-method","text":"Chambolle-Pock method CP = Algorithm( Chambolle-Pock method ) f, g = CP.add_function( f , g ) x1, x2, x3 = CP.add_var( x1 , x2 , x3 ) tau, sigma = CP.add_parameter( tau , sigma ) CP.add_update(x3, x1) CP.add_update(x1, lin.prox(f, tau)(x1 - tau*x2)) CP.add_update(x2, lin.prox(g, sigma)(x2 + sigma*(2*x1 - x3))) CP.parse() lin.test_conjugation(DR, CP)","title":"Check conjugation (Douglas-Rachdford splitting and Chambolle-Pock method)"},{"location":"library/","text":"Algorithm Library Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. The algorithms can be accessed through name abbreviations. Currently, the algorithm library includes: Gradient descent method, accessed by Gr Nesterov's accelerated gradient method , accessed by Ng Heavy-ball method , accessed by Hb Triple momentum algorithm , accessed by Tm Proximal point method , accessed by Pp Proximal point method with relaxation , accessed by Pp_r Proximal gradient method , accessed by Pg Douglas-Rachford splitting , accessed by Dr Permutation of Douglas-Rachford splitting , accessed by Dr_p Peaceman-Rachford splitting method , accessed by Pr Alternating direction method of multipliers (ADMM) , accessed by Admm Chambolle-Pock method , accessed by Cp Davis-Yin splitting method , accessed by Dy Extragradient method , accessed by Eg Extragradient method by Korpelevich and Antipin , accessed by Eg_ka Extragradient method by Tseng , accessed by Eg_t Reflected gradient method by Malitsky , accessed by Rg The whole library is accessed by algo_library.library . The following code checks equivalence between Gradient descent method and Triple momentum method in the library. import linnaeus as lin lin.is_equivalent(lin.Gr, lin.Tm) The results are the same as the previous example . Further, the next example checks equivalence of Gradient descent method among all the algorithms in the library. lin.is_equivalent(lin.Gr, lin.algo_library.library)","title":"Algorithm Library"},{"location":"library/#algorithm-library","text":"Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. The algorithms can be accessed through name abbreviations. Currently, the algorithm library includes: Gradient descent method, accessed by Gr Nesterov's accelerated gradient method , accessed by Ng Heavy-ball method , accessed by Hb Triple momentum algorithm , accessed by Tm Proximal point method , accessed by Pp Proximal point method with relaxation , accessed by Pp_r Proximal gradient method , accessed by Pg Douglas-Rachford splitting , accessed by Dr Permutation of Douglas-Rachford splitting , accessed by Dr_p Peaceman-Rachford splitting method , accessed by Pr Alternating direction method of multipliers (ADMM) , accessed by Admm Chambolle-Pock method , accessed by Cp Davis-Yin splitting method , accessed by Dy Extragradient method , accessed by Eg Extragradient method by Korpelevich and Antipin , accessed by Eg_ka Extragradient method by Tseng , accessed by Eg_t Reflected gradient method by Malitsky , accessed by Rg The whole library is accessed by algo_library.library . The following code checks equivalence between Gradient descent method and Triple momentum method in the library. import linnaeus as lin lin.is_equivalent(lin.Gr, lin.Tm) The results are the same as the previous example . Further, the next example checks equivalence of Gradient descent method among all the algorithms in the library. lin.is_equivalent(lin.Gr, lin.algo_library.library)","title":"Algorithm Library"},{"location":"quick_tutorial/","text":"Quick Tutorial In this quick tutorial, we define two algorithms and show that they are oracle-equivalent. The first algorithm, Import linnaeus and Algorithm class, import linnaeus as lin from linnaeus import Algorithm Define the first algorithm as algo1 with name Algoritm 1 , algo1 = Algorithm( Algorithm 1 ) Add variables x1 , x2 , and x3 to algo1 , x1, x2, x3 = algo1.add_var( x1 , x2 , x3 ) Add oracle gradf , gradient of f to algo1 , gradf = algo1.add_oracle( gradf ) Add update equations: # x3 - 2x1 - x2 algo1.add_update(x3, 2*x1 - x2) # x2 - x1 algo1.add_update(x2, x1) # x1 - x3 - 1/10*gradf(x3) algo1.add_update(x1, x3 - 1/10*gradf(x3)) Parse algo1 : algo1.parse() System parses algo1 and returns the update equations, The second algorithm, Define the second algorithm as algo2 and parse it: algo2 = Algorithm( Algorithm 2 ) xi1 = algo2.add_var( xi1 ) gradf = algo2.add_oracle( gradf ) # xi3 - xi1 algo2.add_update(xi3, xi1) # xi1 - xi1 - xi2 - 1/5*gradf(xi1) algo2.add_update(xi1, xi1 - xi2 - 1/5*gradf(xi3)) # xi2 - xi2 + 1/10*gradf(xi3) algo2.add_update(xi2, xi2 + 1/10*gradf(xi3)) algo2.parse() System parses algo2 and returns the update equations, Check oracle equivalence : lin.is_equivalent(algo1, algo2) System returns True which shows that algo1 and algo2 are oracle-equivalent.","title":"Quick Tutorial"},{"location":"quick_tutorial/#quick-tutorial","text":"In this quick tutorial, we define two algorithms and show that they are oracle-equivalent. The first algorithm, Import linnaeus and Algorithm class, import linnaeus as lin from linnaeus import Algorithm Define the first algorithm as algo1 with name Algoritm 1 , algo1 = Algorithm( Algorithm 1 ) Add variables x1 , x2 , and x3 to algo1 , x1, x2, x3 = algo1.add_var( x1 , x2 , x3 ) Add oracle gradf , gradient of f to algo1 , gradf = algo1.add_oracle( gradf ) Add update equations: # x3 - 2x1 - x2 algo1.add_update(x3, 2*x1 - x2) # x2 - x1 algo1.add_update(x2, x1) # x1 - x3 - 1/10*gradf(x3) algo1.add_update(x1, x3 - 1/10*gradf(x3)) Parse algo1 : algo1.parse() System parses algo1 and returns the update equations, The second algorithm, Define the second algorithm as algo2 and parse it: algo2 = Algorithm( Algorithm 2 ) xi1 = algo2.add_var( xi1 ) gradf = algo2.add_oracle( gradf ) # xi3 - xi1 algo2.add_update(xi3, xi1) # xi1 - xi1 - xi2 - 1/5*gradf(xi1) algo2.add_update(xi1, xi1 - xi2 - 1/5*gradf(xi3)) # xi2 - xi2 + 1/10*gradf(xi3) algo2.add_update(xi2, xi2 + 1/10*gradf(xi3)) algo2.parse() System parses algo2 and returns the update equations, Check oracle equivalence : lin.is_equivalent(algo1, algo2) System returns True which shows that algo1 and algo2 are oracle-equivalent.","title":"Quick Tutorial"}]}