{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"basic_types/","text":"Basic Types The major building block is called an algorithm. An algorithm consists of expressions including variables, parameters, functions, oracles and update equations. Linnaeus is developed based on python symbolic package sympy, and all the expressions are defined symbolically. Algorithms Algorithm is the major building block. It can be defined using the keyword Algorithm along with the name of the algorithm. # import linnaeus and Algorithm class import linnaeus as lin from linnaeus import Algorithm # define an algorithm algo1 named as Algorithm 1 algo1 = Algorithm( Algorithm 1 ) Expressions such as variables, parameters, functions, oracles and update equations are all treated as attributes to an algorithm object. In other words, all the expressions are algorithm specific and can only be used within its corresponding algorithm. Further, the users must define an algorithm before they define other expressions. Variables Variables are regarded as algorithm states. Variables are declared and added to an algorithm using syntax add_var along with the names of variables. Add variables $x_1$ and $x_2$ to algo1 . # add variables x1 and x2 to algo1 x1, x2 = algo1.add_var( x1 , x2 ) Each algorithm state must be updated during on each block of iteration. The updated variables can be accessed by syntax update . # get access to the updated versions of x1 and x2 x1u, x2u = algo1.update(x1, x2) Parameters Parameters can be a scalar, a vector or a matrix. The main difference between a scalar and a vector or a matrix is whether it is commutative. Parameters can be declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or a matrix, the argument commutative should be set as False. It is unnecessary to specify the size of the vector or the matrix, since they are all regarded as abstract expressions. add a scalar parameter t t = algo1.add_parameter( t ) # add a matrix parameter L L = algo1.add_parameter( L , commutative = False) Oracles We assume an oracle model of optimization. Algorithm analysis results vary with different levels of information acquired by oracles about the functions and the problem or in order words different oracles. In Linnaeus, we provide two approaches to declare and add oracles to an algorithm. The first approach is to define oracles in the top level as black boxes. When parsing the algorithm, the system treats each oracle as a whole and does not care what happens inside each oracle. Under this approach, an oracle can be declared and defined using syntax add_oracle . # add oracle gradient of f in the first approach gradf = algo1.add_oracle( gradf ) # add oracle prox of g in the first approach proxg = algo1.add_oracle( proxg ) The second approach is to define oracles in the bottom level of gradients or subgradients. When parsing an algorithm, all the oracles will be decomposed into gradients or subgradients and the gradients or subgradients are treated as nonlinearities of the algorithm. Under this approach, functions must be defined and added to the algorithm before defining oracles. Syntax add_function is used to declare and add functions to an algorithm. # add function f f = algo1.add_function( f ) We provide four types of oracles that can be decomposed into gradients or subgradients including Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin # gradient of f with respect to x1 lin.grad(f)(x1) # prox of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x)) Update equations Update equations define the iterative procedures of an algorithm. Since all the algorithm states must be updated within each block of iteration, all the update equations have common structure that an updated variable equals an expression of variables, parameters and oracles. We can declare and add an update equation by syntax add_update . # add update equation algo1.add_update(x1, x2 - gradf(x2)) # x1 - x2 - gradf(x2) algo1.add_update(x2, x1 + proxg(x1)) # x2 - x1 + proxg(x1) By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is interpreted as the updated x1. For some cases, we can change the default setting by syntax set_auto . # change default setting of auto algo1.set_auto(False) Under this condition, we have a different interpretation of the update equations. algo1.set_auto(False) algo1.add_update(x1, x2 - gradf(x2)) # x1+ = x2 - gradf(x2) algo1.add_update(x2, x1 + proxg(x1)) # x2+ = x1 + proxg(x1)","title":"Basic Types"},{"location":"basic_types/#basic-types","text":"The major building block is called an algorithm. An algorithm consists of expressions including variables, parameters, functions, oracles and update equations. Linnaeus is developed based on python symbolic package sympy, and all the expressions are defined symbolically.","title":"Basic Types"},{"location":"basic_types/#algorithms","text":"Algorithm is the major building block. It can be defined using the keyword Algorithm along with the name of the algorithm. # import linnaeus and Algorithm class import linnaeus as lin from linnaeus import Algorithm # define an algorithm algo1 named as Algorithm 1 algo1 = Algorithm( Algorithm 1 ) Expressions such as variables, parameters, functions, oracles and update equations are all treated as attributes to an algorithm object. In other words, all the expressions are algorithm specific and can only be used within its corresponding algorithm. Further, the users must define an algorithm before they define other expressions.","title":"Algorithms"},{"location":"basic_types/#variables","text":"Variables are regarded as algorithm states. Variables are declared and added to an algorithm using syntax add_var along with the names of variables. Add variables $x_1$ and $x_2$ to algo1 . # add variables x1 and x2 to algo1 x1, x2 = algo1.add_var( x1 , x2 ) Each algorithm state must be updated during on each block of iteration. The updated variables can be accessed by syntax update . # get access to the updated versions of x1 and x2 x1u, x2u = algo1.update(x1, x2)","title":"Variables"},{"location":"basic_types/#parameters","text":"Parameters can be a scalar, a vector or a matrix. The main difference between a scalar and a vector or a matrix is whether it is commutative. Parameters can be declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or a matrix, the argument commutative should be set as False. It is unnecessary to specify the size of the vector or the matrix, since they are all regarded as abstract expressions. add a scalar parameter t t = algo1.add_parameter( t ) # add a matrix parameter L L = algo1.add_parameter( L , commutative = False)","title":"Parameters"},{"location":"basic_types/#oracles","text":"We assume an oracle model of optimization. Algorithm analysis results vary with different levels of information acquired by oracles about the functions and the problem or in order words different oracles. In Linnaeus, we provide two approaches to declare and add oracles to an algorithm. The first approach is to define oracles in the top level as black boxes. When parsing the algorithm, the system treats each oracle as a whole and does not care what happens inside each oracle. Under this approach, an oracle can be declared and defined using syntax add_oracle . # add oracle gradient of f in the first approach gradf = algo1.add_oracle( gradf ) # add oracle prox of g in the first approach proxg = algo1.add_oracle( proxg ) The second approach is to define oracles in the bottom level of gradients or subgradients. When parsing an algorithm, all the oracles will be decomposed into gradients or subgradients and the gradients or subgradients are treated as nonlinearities of the algorithm. Under this approach, functions must be defined and added to the algorithm before defining oracles. Syntax add_function is used to declare and add functions to an algorithm. # add function f f = algo1.add_function( f ) We provide four types of oracles that can be decomposed into gradients or subgradients including Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin # gradient of f with respect to x1 lin.grad(f)(x1) # prox of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x))","title":"Oracles"},{"location":"basic_types/#update-equations","text":"Update equations define the iterative procedures of an algorithm. Since all the algorithm states must be updated within each block of iteration, all the update equations have common structure that an updated variable equals an expression of variables, parameters and oracles. We can declare and add an update equation by syntax add_update . # add update equation algo1.add_update(x1, x2 - gradf(x2)) # x1 - x2 - gradf(x2) algo1.add_update(x2, x1 + proxg(x1)) # x2 - x1 + proxg(x1) By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is interpreted as the updated x1. For some cases, we can change the default setting by syntax set_auto . # change default setting of auto algo1.set_auto(False) Under this condition, we have a different interpretation of the update equations. algo1.set_auto(False) algo1.add_update(x1, x2 - gradf(x2)) # x1+ = x2 - gradf(x2) algo1.add_update(x2, x1 + proxg(x1)) # x2+ = x1 + proxg(x1)","title":"Update equations"},{"location":"examples/","text":"Examples Checking equivalence (linear transform) import linnaeus as lin from linnaeus import Algorithm algo1 = Algorithm( algo1 ) x1, x2 = algo1.add_var( x1 , x2 ) gradf = algo1.add_oracle( gradf ) algo1.set_auto(False) # x1+ = 2x1 - x2 - 1/10*gradf(2x1 - x2) algo1.add_update(x1, 2 * x1 - x2 - 1/10 * gradf(2*x1 - x2)) # x2+ = x1 algo1.add_update(x2, x1) algo2 = Algorithm( algo2 ) y1, y2 = algo2.add_var( y1 , y2 ) gradf = algo2.add_oracle( gradf ) algo2.set_auto(False) # y1+ = y1 - y2 - 1/5*gradf(y1) algo2.add_update(y1, y1 - y2 - 1/5 * gradf(y1)) # y2+ = y2 + 1/10*gradf(y1) algo2.add_update(y2, y2 + 1/10 * gradf(y1)) algo1.parse() algo2.parse() lin.is_equivalent(algo1, algo2) Checking permutation import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( algo3 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) # x1 - proxf(x3) algo3.add_update(x1, proxf(x3)) # x2 - proxg(2x1 - x3) algo3.add_update(x2, proxg(2 * x1 - x3)) # x3 - x3 + x2 - x1 algo3.add_update(x3, x3 + x2 - x1) algo4 = Algorithm( algo4 ) y1, y2 = algo4.add_var( y1 , y2 ) proxf, proxg = algo4.add_oracle( proxf , proxg ) # y1 - proxg(-y1 + 2y2) + y1 - y2 algo4.add_update(y1, proxg(-y1 + 2 * y2) + y1 - y2) # y2 - proxf(y1) algo4.add_update(y2, proxf(y1)) algo3.parse() algo4.parse() lin.is_permutation(algo3, algo4) Checking repetition import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) t = algo5.add_parameter( t ) x1 = algo5.add_var( x1 ) f = algo5.add_function( f ) # x1 - x1 - t*gradf(x1) algo5.add_update(x1, x1 - t * lin.grad(f)(x1)) algo6 = Algorithm( algo6 ) y1, y2 = algo6.add_var( y1 , y2 ) t = algo6.add_parameter( t ) f = algo6.add_function( f ) # y2 - y1 - t*gradf(y1) algo6.add_update(y2, y1 - t * lin.grad(f)(y1)) # y1 - y2 - t*gradf(y2) algo6.add_update(y1, y2 - t * lin.grad(f)(y2)) algo5.parse() algo6.parse() lin.is_repetition(algo5, algo6) Checking conjugation import linnaeus as lin from linnaeus import Algorithm algo7 = Algorithm( algo7 ) x1, x2, x3 = algo7.add_var( x1 , x2 , x3 ) t = algo7.add_parameter( t ) f, g = algo7.add_function( f , g ) # x1 - prox(f,t)(x3) algo7.add_update(x1, lin.prox(f, t)(x3)) # x2 - prox(g,t)(2x1 - x3) algo7.add_update(x2, lin.prox(g, t)(2 * x1 - x3)) # x3 - x3 + x2 - x1 algo7.add_update(x3, x3 + x2 - x1) algo8 = Algorithm( algo8 ) t = algo8.add_parameter( t ) f, g = algo8.add_function( f , g ) t = algo8.add_parameter( t ) x1, x2 = algo8.add_var( x1 , x2 ) x1u = algo8.update(x1) algo8.set_auto(False) # x1+ = prox(f, t)(x1 - t * x2) algo8.add_update(x1, lin.prox(f, t)(x1 - t * x2)) # x2+ = prox(g, 1/t)(x2 + 1/t * (2x1+ - x1)) algo8.add_update(x2, lin.prox(g, 1/t)(x2 + 1/t * (2 * x1u - x1))) algo7.parse() algo8.parse() lin.is_conjugation(algo7, algo8)","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#checking-equivalence-linear-transform","text":"import linnaeus as lin from linnaeus import Algorithm algo1 = Algorithm( algo1 ) x1, x2 = algo1.add_var( x1 , x2 ) gradf = algo1.add_oracle( gradf ) algo1.set_auto(False) # x1+ = 2x1 - x2 - 1/10*gradf(2x1 - x2) algo1.add_update(x1, 2 * x1 - x2 - 1/10 * gradf(2*x1 - x2)) # x2+ = x1 algo1.add_update(x2, x1) algo2 = Algorithm( algo2 ) y1, y2 = algo2.add_var( y1 , y2 ) gradf = algo2.add_oracle( gradf ) algo2.set_auto(False) # y1+ = y1 - y2 - 1/5*gradf(y1) algo2.add_update(y1, y1 - y2 - 1/5 * gradf(y1)) # y2+ = y2 + 1/10*gradf(y1) algo2.add_update(y2, y2 + 1/10 * gradf(y1)) algo1.parse() algo2.parse() lin.is_equivalent(algo1, algo2)","title":"Checking equivalence (linear transform)"},{"location":"examples/#checking-permutation","text":"import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( algo3 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) # x1 - proxf(x3) algo3.add_update(x1, proxf(x3)) # x2 - proxg(2x1 - x3) algo3.add_update(x2, proxg(2 * x1 - x3)) # x3 - x3 + x2 - x1 algo3.add_update(x3, x3 + x2 - x1) algo4 = Algorithm( algo4 ) y1, y2 = algo4.add_var( y1 , y2 ) proxf, proxg = algo4.add_oracle( proxf , proxg ) # y1 - proxg(-y1 + 2y2) + y1 - y2 algo4.add_update(y1, proxg(-y1 + 2 * y2) + y1 - y2) # y2 - proxf(y1) algo4.add_update(y2, proxf(y1)) algo3.parse() algo4.parse() lin.is_permutation(algo3, algo4)","title":"Checking permutation"},{"location":"examples/#checking-repetition","text":"import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) t = algo5.add_parameter( t ) x1 = algo5.add_var( x1 ) f = algo5.add_function( f ) # x1 - x1 - t*gradf(x1) algo5.add_update(x1, x1 - t * lin.grad(f)(x1)) algo6 = Algorithm( algo6 ) y1, y2 = algo6.add_var( y1 , y2 ) t = algo6.add_parameter( t ) f = algo6.add_function( f ) # y2 - y1 - t*gradf(y1) algo6.add_update(y2, y1 - t * lin.grad(f)(y1)) # y1 - y2 - t*gradf(y2) algo6.add_update(y1, y2 - t * lin.grad(f)(y2)) algo5.parse() algo6.parse() lin.is_repetition(algo5, algo6)","title":"Checking repetition"},{"location":"examples/#checking-conjugation","text":"import linnaeus as lin from linnaeus import Algorithm algo7 = Algorithm( algo7 ) x1, x2, x3 = algo7.add_var( x1 , x2 , x3 ) t = algo7.add_parameter( t ) f, g = algo7.add_function( f , g ) # x1 - prox(f,t)(x3) algo7.add_update(x1, lin.prox(f, t)(x3)) # x2 - prox(g,t)(2x1 - x3) algo7.add_update(x2, lin.prox(g, t)(2 * x1 - x3)) # x3 - x3 + x2 - x1 algo7.add_update(x3, x3 + x2 - x1) algo8 = Algorithm( algo8 ) t = algo8.add_parameter( t ) f, g = algo8.add_function( f , g ) t = algo8.add_parameter( t ) x1, x2 = algo8.add_var( x1 , x2 ) x1u = algo8.update(x1) algo8.set_auto(False) # x1+ = prox(f, t)(x1 - t * x2) algo8.add_update(x1, lin.prox(f, t)(x1 - t * x2)) # x2+ = prox(g, 1/t)(x2 + 1/t * (2x1+ - x1)) algo8.add_update(x2, lin.prox(g, 1/t)(x2 + 1/t * (2 * x1u - x1))) algo7.parse() algo8.parse() lin.is_conjugation(algo7, algo8)","title":"Checking conjugation"},{"location":"home/","text":"Linnaeus Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. Users can describe an algorithm in natural, mathematical syntax with variables, parameters, functions, oracles and update equations. The system will automatically translate the input algorithm into a canonical form and use the canonical form to parse the algorithm along with classification and identification of equivalence and transformations. Linnaeus can check algorithm relations including Equivalence (oracle equivalence) Linear transform (linear state equivalence) Permutation (shift equivalence) Repetition Duality Conjugation Installation Installing Linnaeus using pip from github : pip install git+https://github.com/QCGroup/linnaeus Algorithm library Linnaeus include an algorithm library to serve as a search engine. Users can check the potential relations between the input algorithm and algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method ADMM Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Home"},{"location":"home/#linnaeus","text":"Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. Users can describe an algorithm in natural, mathematical syntax with variables, parameters, functions, oracles and update equations. The system will automatically translate the input algorithm into a canonical form and use the canonical form to parse the algorithm along with classification and identification of equivalence and transformations. Linnaeus can check algorithm relations including Equivalence (oracle equivalence) Linear transform (linear state equivalence) Permutation (shift equivalence) Repetition Duality Conjugation","title":"Linnaeus"},{"location":"home/#installation","text":"Installing Linnaeus using pip from github : pip install git+https://github.com/QCGroup/linnaeus","title":"Installation"},{"location":"home/#algorithm-library","text":"Linnaeus include an algorithm library to serve as a search engine. Users can check the potential relations between the input algorithm and algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method ADMM Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Algorithm library"},{"location":"identification/","text":"Indentification Suppose an algorithm is already defined and variables, parameters, oracles and update equations are added to the algorithm, the next step is to parse the algorithm. Users can use syntax parse to translate the input algorithm into the canonical form and use the canonical form to perform subsequent analysis such as equivalence identification. algo1.parse() Linnaeus provides a set of package functions to check algorithm equivalence and transformations. These package functions take objects of Algorithm class as input and return Boolean values. Equivalence is_equivalent() (Checks both oracle equivalence and linear transform) Permutation is_permutation() Repetition is_repetition() Duality is_duality() Conjugation is_conjugation() These functions take two arguments, one is the target algorithm to parse and the other is the reference algorithm or a list of reference algorithms. # check equivalence between algo1 and algo2 lin.is_equivalent(algo1, algo2) # check equivalence between algo1 and [algo2, algo3] lin.is_equivalent(algo1, [algo2, algo3]) # check permutation between algo1 and algo2 lin.is_permutation(algo1, algo2) # check conjugation between algo1 and algo2 lin.is_conjugation(algo1, algo2) # check duality between algo1 and algo2 lin.is_duality(algo1, algo2) # check repetition between algo1 and algo2 lin.is_repetition(algo1, algo2)","title":"Identification"},{"location":"identification/#indentification","text":"Suppose an algorithm is already defined and variables, parameters, oracles and update equations are added to the algorithm, the next step is to parse the algorithm. Users can use syntax parse to translate the input algorithm into the canonical form and use the canonical form to perform subsequent analysis such as equivalence identification. algo1.parse() Linnaeus provides a set of package functions to check algorithm equivalence and transformations. These package functions take objects of Algorithm class as input and return Boolean values. Equivalence is_equivalent() (Checks both oracle equivalence and linear transform) Permutation is_permutation() Repetition is_repetition() Duality is_duality() Conjugation is_conjugation() These functions take two arguments, one is the target algorithm to parse and the other is the reference algorithm or a list of reference algorithms. # check equivalence between algo1 and algo2 lin.is_equivalent(algo1, algo2) # check equivalence between algo1 and [algo2, algo3] lin.is_equivalent(algo1, [algo2, algo3]) # check permutation between algo1 and algo2 lin.is_permutation(algo1, algo2) # check conjugation between algo1 and algo2 lin.is_conjugation(algo1, algo2) # check duality between algo1 and algo2 lin.is_duality(algo1, algo2) # check repetition between algo1 and algo2 lin.is_repetition(algo1, algo2)","title":"Indentification"},{"location":"quick_tutorial/","text":"Quick Tutorial In this quick tutorial, we define two algorithms and check equivalence. Define the first algorithm : # import linnaeus and Algorithm class import linnaeus as lin from linnaeus import Algorithm # define the first algorithm algo1 = Algorithm( algo1 ) # define variables x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) # define oracle gradf gradf = algo3.add_oracle( gradf ) # add update equations algo3.add_update(x3, x2) # x3 - x2 algo3.add_update(x2, x1) # x2 - x1 algo3.add_update(x1, 3 * x1 - 2 * x3 + 1/5 * gradf(-x1 + 2 * x3)) # x1 - 3x1 - 2x3 + 1/5*gradf(-x1 + 2x3) # parse the algorithm algo3.parse() Define the second algorithm : algo2 = Algorithm( algo2 ) y1 = algo2.add_var( y1 ) gradf = algo2.add_oracle( gradf ) algo2.add_update(y1, y1 - 1/5 * gradf(y1)) # y1 - y1 - 1/5*gradf(y1) algo2.parse() Check equivalence : lin.is_equivalent(algo1, algo2) Return is True .","title":"Quick Tutorial"},{"location":"quick_tutorial/#quick-tutorial","text":"In this quick tutorial, we define two algorithms and check equivalence. Define the first algorithm : # import linnaeus and Algorithm class import linnaeus as lin from linnaeus import Algorithm # define the first algorithm algo1 = Algorithm( algo1 ) # define variables x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) # define oracle gradf gradf = algo3.add_oracle( gradf ) # add update equations algo3.add_update(x3, x2) # x3 - x2 algo3.add_update(x2, x1) # x2 - x1 algo3.add_update(x1, 3 * x1 - 2 * x3 + 1/5 * gradf(-x1 + 2 * x3)) # x1 - 3x1 - 2x3 + 1/5*gradf(-x1 + 2x3) # parse the algorithm algo3.parse() Define the second algorithm : algo2 = Algorithm( algo2 ) y1 = algo2.add_var( y1 ) gradf = algo2.add_oracle( gradf ) algo2.add_update(y1, y1 - 1/5 * gradf(y1)) # y1 - y1 - 1/5*gradf(y1) algo2.parse() Check equivalence : lin.is_equivalent(algo1, algo2) Return is True .","title":"Quick Tutorial"}]}