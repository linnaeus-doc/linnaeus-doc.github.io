{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Linnaeus Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. An algorithm is specified by defining variables, parameters, functions, oracles, and update equations. Linnaeus can check algorithm relations including Oracle equivalence (algorithms generate identical sequence of oracle calls) Linear state transform (states are identical up to a linear map) Permutation (shift equivalence, algorithms generate identical sequence of oracle calls up to a shift) Repetition (one algorithm repeats the updates of another algorithm) Conjugation (algorithm calls conjugate function oracles, i.e. Fenchel conjugate) Duality (conjugation on all algorithm oracles) For more information about algorithm equivalence and relations, see our paper. Installation To install using pip, run: pip install git+https://github.com/QCGroup/linnaeus To install from source, first make sure setuptools has been installed. Then, Clone the Linnaeus git repo. Navigate to the top-level of the directory and run: python setup.py install To test the installation with nose2, first make sure nose2 has been installed. Then run: nose2 linnaeus The requirements are: SymPy = 1.6.2 NumPy = 1.16 SciPy = 1.2.1 Python 3.x Algorithm library Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method Alternating direction method of multipliers (ADMM) Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Home"},{"location":"#linnaeus","text":"Linnaeus is a python package for the classification of iterative algorithms and identification of relations between algorithms. An algorithm is specified by defining variables, parameters, functions, oracles, and update equations. Linnaeus can check algorithm relations including Oracle equivalence (algorithms generate identical sequence of oracle calls) Linear state transform (states are identical up to a linear map) Permutation (shift equivalence, algorithms generate identical sequence of oracle calls up to a shift) Repetition (one algorithm repeats the updates of another algorithm) Conjugation (algorithm calls conjugate function oracles, i.e. Fenchel conjugate) Duality (conjugation on all algorithm oracles) For more information about algorithm equivalence and relations, see our paper.","title":"Linnaeus"},{"location":"#installation","text":"To install using pip, run: pip install git+https://github.com/QCGroup/linnaeus To install from source, first make sure setuptools has been installed. Then, Clone the Linnaeus git repo. Navigate to the top-level of the directory and run: python setup.py install To test the installation with nose2, first make sure nose2 has been installed. Then run: nose2 linnaeus The requirements are: SymPy = 1.6.2 NumPy = 1.16 SciPy = 1.2.1 Python 3.x","title":"Installation"},{"location":"#algorithm-library","text":"Linnaeus includes an algorithm library to serve as a reference. Users can check the potential relations between the input algorithm and reference algorithms in the library. Currently, the algorithm library includes: Gradient descent method Nesterov's accelerated gradient method (with generalization) Heavy-ball method Proximal point method (with generalization) Proximal gradient method (ISTA, FISTA) Douglas-Rachford splitting method (with different versions) Peaceman-Rachford splitting method Alternating direction method of multipliers (ADMM) Chambolle-Pock method Davis-Yin splitting method Extragradient method (with different versions)","title":"Algorithm library"},{"location":"basic_types/","text":"Basic Types The major building block is called an algorithm. An algorithm is defined with variables, parameters, functions, oracles, and update equations. All the expressions in Linnaeus are defined symbolically using SymPy. Algorithms Algorithm is defined using keyword Algorithm along with the name of the algorithm. The following code defines an Algorithm as new_algo named my new algorithm . new_algo = Algorithm( my new algorithm ) Expressions such as variables, parameters, functions, oracles, and update equations are all attributes to an algorithm object. An algorithm must be defined before other expressions are defined and added to it. Variables Variables are algorithm states. They are declared and added to an algorithm using syntax add_var along with the names of the variables. In the following example, we add variables x1 and x2 to new_algo . x1, x2 = new_algo.add_var( x1 , x2 ) Each algorithm state (each variable) must be updated at each iteration. The updated variables can be accessed by syntax update . Here we access the updated x1 with x1u and updated x2 with x2u in the following code. x1u, x2u = new_algo.update(x1, x2) Parameters Parameters of an algorithm can be declared as scalar (commutative) or vector or matrix (noncommutative). Parameters are declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or matrix, the argument commutative should be set as False . The default setting of argument commutative is True . There is no need to specialize the dimensions of vectors or matrices, since they are symbolic. The following code shows how to add scalar t and matrix L to new_algo . t = new_algo.add_parameter( t ) L = new_algo.add_parameter( L , commutative = False) Oracles Linnaeus provides two approaches to declare and add oracles to an algorithm. Black-box approach The black-box approach is to define oracles as black boxes. When parsing the algorithm, the system treats each oracle as a distinct entity unrelated to any other oracle. An oracle declared using syntax add_oracle uses the black-box approach For example, we declare oracles gradient of f and proximal operator of g with the following code. gradf = new_algo.add_oracle( gradf ) proxg = new_algo.add_oracle( proxg ) Functional approach The functional approach is to define oracles in terms of the (sub)gradient of a function. When parsing an algorithm, all the oracles will be decomposed into (sub)gradients. This approach is important to allow detection algorithm conjugation. This example shows the details. With the functional approach, functions must be defined and added to the algorithm using syntax add_function before defining oracles. The following example shows to define function f and add it to new_algo f = new_algo.add_function( f ) Linnaeus provides four types of oracles that can be decomposed into (sub)gradients, Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin import linnaeus as lin # gradient of f with respect to x1 lin.grad(f)(x1) # proximal operator of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x)) To use the projection oracle, a set must be declared in advance with syntax add_set . Update equations Update equations define the iterative procedures of an algorithm. All the update equations have common structure that an updated variable equals an expression of variables, parameters, and oracles. An update equation is defined with syntax add_update . new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) The update equations in the above example are interpreted as Or interpreted as equalities, By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is considered as the updated x1 , as the x1^+ in the second equality interpretation. For some cases, we can change the default setting by syntax set_auto , such as new_algo.set_auto(False) new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) Under this setting, we have a different interpretation of the update equations, Warning! To avoid overlap and misleading in expressions, it is highly recommanded that each algorithm should have its own variables, parameters, etc, and those expressions should only be used within this algorithm! For example, algo1 = Algorithm( my first algorithm ) x1, x2 = algo1.add_var( x1 , x2 ) t, h = algo1.add_parameter( t , h ) algo1.add_update(x1, x2 - t*x2) algo1.add_update(x2, x1 - h*x2) algo2 = Algorithm( my second algorithm ) x1, x2 = algo2.add_var( x1 , x2 ) t, h = algo2.add_parameter( t , h ) algo2.add_update(x1, x2 - h*x1) algo2.add_update(x2, x1 - t*x2) Variables x1 and x2 , parameters t and h are declared within the first algorithm algo1 . They should only be used within algo1 , such as the update equations of it. For the second algorithm algo2 , if we still want to use variables x1 , x2 , and parameters t , h , they should be declared again within algo2 .","title":"Basic Types"},{"location":"basic_types/#basic-types","text":"The major building block is called an algorithm. An algorithm is defined with variables, parameters, functions, oracles, and update equations. All the expressions in Linnaeus are defined symbolically using SymPy.","title":"Basic Types"},{"location":"basic_types/#algorithms","text":"Algorithm is defined using keyword Algorithm along with the name of the algorithm. The following code defines an Algorithm as new_algo named my new algorithm . new_algo = Algorithm( my new algorithm ) Expressions such as variables, parameters, functions, oracles, and update equations are all attributes to an algorithm object. An algorithm must be defined before other expressions are defined and added to it.","title":"Algorithms"},{"location":"basic_types/#variables","text":"Variables are algorithm states. They are declared and added to an algorithm using syntax add_var along with the names of the variables. In the following example, we add variables x1 and x2 to new_algo . x1, x2 = new_algo.add_var( x1 , x2 ) Each algorithm state (each variable) must be updated at each iteration. The updated variables can be accessed by syntax update . Here we access the updated x1 with x1u and updated x2 with x2u in the following code. x1u, x2u = new_algo.update(x1, x2)","title":"Variables"},{"location":"basic_types/#parameters","text":"Parameters of an algorithm can be declared as scalar (commutative) or vector or matrix (noncommutative). Parameters are declared and added to an algorithm using syntax add_parameter along with the names of parameters. To add a vector or matrix, the argument commutative should be set as False . The default setting of argument commutative is True . There is no need to specialize the dimensions of vectors or matrices, since they are symbolic. The following code shows how to add scalar t and matrix L to new_algo . t = new_algo.add_parameter( t ) L = new_algo.add_parameter( L , commutative = False)","title":"Parameters"},{"location":"basic_types/#oracles","text":"Linnaeus provides two approaches to declare and add oracles to an algorithm.","title":"Oracles"},{"location":"basic_types/#black-box-approach","text":"The black-box approach is to define oracles as black boxes. When parsing the algorithm, the system treats each oracle as a distinct entity unrelated to any other oracle. An oracle declared using syntax add_oracle uses the black-box approach For example, we declare oracles gradient of f and proximal operator of g with the following code. gradf = new_algo.add_oracle( gradf ) proxg = new_algo.add_oracle( proxg )","title":"Black-box approach"},{"location":"basic_types/#functional-approach","text":"The functional approach is to define oracles in terms of the (sub)gradient of a function. When parsing an algorithm, all the oracles will be decomposed into (sub)gradients. This approach is important to allow detection algorithm conjugation. This example shows the details. With the functional approach, functions must be defined and added to the algorithm using syntax add_function before defining oracles. The following example shows to define function f and add it to new_algo f = new_algo.add_function( f ) Linnaeus provides four types of oracles that can be decomposed into (sub)gradients, Gradient with syntax grad Proximal operator with syntax prox Projection with syntax proj Argmin operator with syntax argmin import linnaeus as lin # gradient of f with respect to x1 lin.grad(f)(x1) # proximal operator of f with respect to x2 and parameter t lin.prox(f,t)(x2) # projection x1 onto set C lin.proj(C)(x1) # argmin of f(x) + g(x) lin.argmin(x, f(x) + g(x)) To use the projection oracle, a set must be declared in advance with syntax add_set .","title":"Functional approach"},{"location":"basic_types/#update-equations","text":"Update equations define the iterative procedures of an algorithm. All the update equations have common structure that an updated variable equals an expression of variables, parameters, and oracles. An update equation is defined with syntax add_update . new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) The update equations in the above example are interpreted as Or interpreted as equalities, By default setting, variables which have already been updated will be substituted with their updated versions. Thus, x1 in the second update equation is considered as the updated x1 , as the x1^+ in the second equality interpretation. For some cases, we can change the default setting by syntax set_auto , such as new_algo.set_auto(False) new_algo.add_update(x1, x2 - gradf(x2)) new_algo.add_update(x2, x1 + proxg(x1)) Under this setting, we have a different interpretation of the update equations,","title":"Update equations"},{"location":"basic_types/#warning","text":"To avoid overlap and misleading in expressions, it is highly recommanded that each algorithm should have its own variables, parameters, etc, and those expressions should only be used within this algorithm! For example, algo1 = Algorithm( my first algorithm ) x1, x2 = algo1.add_var( x1 , x2 ) t, h = algo1.add_parameter( t , h ) algo1.add_update(x1, x2 - t*x2) algo1.add_update(x2, x1 - h*x2) algo2 = Algorithm( my second algorithm ) x1, x2 = algo2.add_var( x1 , x2 ) t, h = algo2.add_parameter( t , h ) algo2.add_update(x1, x2 - h*x1) algo2.add_update(x2, x1 - t*x2) Variables x1 and x2 , parameters t and h are declared within the first algorithm algo1 . They should only be used within algo1 , such as the update equations of it. For the second algorithm algo2 , if we still want to use variables x1 , x2 , and parameters t , h , they should be declared again within algo2 .","title":"Warning!"},{"location":"detection/","text":"Detection Parse an algorithm Suppose an algorithm is already defined and variables, parameters, oracles, and update equations are added to the algorithm, the next step is to parse the algorithm. Syntax parse is used to translate the input algorithm into a canonical form (transfer function) and use the canonical form to perform subsequent analysis such as equivalence detection. When parsing an algorithm, the state-space realization is provided by the system. With example of gradient descent algorithm, The following code defines the gradient descent algorithm as algo3 and parses it into canonical form. import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( gradient descent algorithm ) x1 = algo3.add_var( x1 ) t = algo3.add_parameter( t ) gradf = algo3.add_oracle( gradf ) algo3.add_update(x1, x1 - t*gradf(x1)) algo3.parse() Detection Linnaeus provides a set of functions to check algorithm equivalence and relations. Oracle equivalence and linear transform, is_equivalent() and test_equivalence() Permutation, is_permutation() and test_permutation() Repetition, is_repetition() and test_repetition() Conjugation, is_conjugation() and test_conjugation() Duality, is_duality() and test_duality() Here is a brief description of algorithm equivalence and relations. For more details, see our paper. These functions take two arguments, the first one is the target algorithm to parse and the second is the reference algorithm or a list of reference algorithms. For each type of algorithm equivalence or relations, the is_ function returns boolean or a list of boolean, simply indicating whether the input algorithm and the reference algorithm are equivalent/related or not. The test_ function returns more details. Specifically, if two algorithms are equivalent/related only when the parameters satisfy a certain condition, the test_ function will return the condition. For illustration, we define the triple momentum algorithm as algo4 and check oracle equivalence between algo3 and algo4 . algo4 = Algorithm( triple momentum algorithm ) x1, x2, x3 = algo4.add_var( x1 , x2 , x3 ) alpha, beta, eta = algo4.add_var( alpha , beta , eta ) gradf = algo4.add_oracle( gradf ) algo4.add_update(x3, x1) algo4.add_update(x1, (1 + beta)*x1 - beta*x2 - alpha*gradf((1 + eta)*x1 - eta*x2)) algo4.add_update(x2, x3) algo4.parse() lin.is_equivalent(algo3, algo4) The system returns True To return the conditions for parameters that yield equivalence, we can use the test_equivalent() function as follows. lin.test_equivalent(algo3, algo4) LaTeX support We recommand users to use an IPython console that LaTeX is installed to check the parameter maps returned by the test_ functions. An IPython notebook with LaTeX support is also recommanded. Transform an algorithm To detect complex relations, Linnaeus provides a set of functions to transform an algorithm. permute(step) , returns a permutation of an algorithm with specific steps set by argument step . The default setting of step is 0, which returns the one-step permutation. step should be an integer and less than the total oracle number of the algorithm. conjugate(conjugate_oracle) , returns the conjugate of an algorithm with respect to the specific oracle set by argument conjugate_oracle . The default setting of conjugate_oracle is 0, which returns the conjugate with respect to the first oracle. conjugate_oracle should be an integer and within the set of oracle indices of the algorithm. If an algorithm contains n oracles, its set of oracle indices is [0, ..., n - 1] . dual() , returns the conjugate of an algorithm with respect to all the oracles. repeat(number) , returns a repetition of an algorithm that repeats the algorithm with number of times. The default setting of number is 2, which repeats the algorithm twice. Commutative property Conjugation of different oracles commutes. Conjugation and permutation also commute. The following code transforms new_algo in different ways. new_algo.permute() new_algo.conjugate(1) new_algo.dual() new_algo.repeat(3) Here is an example demonstrating how to detect complex relations between algorithms using algorithm transformations.","title":"Detection"},{"location":"detection/#detection","text":"","title":"Detection"},{"location":"detection/#parse-an-algorithm","text":"Suppose an algorithm is already defined and variables, parameters, oracles, and update equations are added to the algorithm, the next step is to parse the algorithm. Syntax parse is used to translate the input algorithm into a canonical form (transfer function) and use the canonical form to perform subsequent analysis such as equivalence detection. When parsing an algorithm, the state-space realization is provided by the system. With example of gradient descent algorithm, The following code defines the gradient descent algorithm as algo3 and parses it into canonical form. import linnaeus as lin from linnaeus import Algorithm algo3 = Algorithm( gradient descent algorithm ) x1 = algo3.add_var( x1 ) t = algo3.add_parameter( t ) gradf = algo3.add_oracle( gradf ) algo3.add_update(x1, x1 - t*gradf(x1)) algo3.parse()","title":"Parse an algorithm"},{"location":"detection/#detection_1","text":"Linnaeus provides a set of functions to check algorithm equivalence and relations. Oracle equivalence and linear transform, is_equivalent() and test_equivalence() Permutation, is_permutation() and test_permutation() Repetition, is_repetition() and test_repetition() Conjugation, is_conjugation() and test_conjugation() Duality, is_duality() and test_duality() Here is a brief description of algorithm equivalence and relations. For more details, see our paper. These functions take two arguments, the first one is the target algorithm to parse and the second is the reference algorithm or a list of reference algorithms. For each type of algorithm equivalence or relations, the is_ function returns boolean or a list of boolean, simply indicating whether the input algorithm and the reference algorithm are equivalent/related or not. The test_ function returns more details. Specifically, if two algorithms are equivalent/related only when the parameters satisfy a certain condition, the test_ function will return the condition. For illustration, we define the triple momentum algorithm as algo4 and check oracle equivalence between algo3 and algo4 . algo4 = Algorithm( triple momentum algorithm ) x1, x2, x3 = algo4.add_var( x1 , x2 , x3 ) alpha, beta, eta = algo4.add_var( alpha , beta , eta ) gradf = algo4.add_oracle( gradf ) algo4.add_update(x3, x1) algo4.add_update(x1, (1 + beta)*x1 - beta*x2 - alpha*gradf((1 + eta)*x1 - eta*x2)) algo4.add_update(x2, x3) algo4.parse() lin.is_equivalent(algo3, algo4) The system returns True To return the conditions for parameters that yield equivalence, we can use the test_equivalent() function as follows. lin.test_equivalent(algo3, algo4)","title":"Detection"},{"location":"detection/#latex-support","text":"We recommand users to use an IPython console that LaTeX is installed to check the parameter maps returned by the test_ functions. An IPython notebook with LaTeX support is also recommanded.","title":"LaTeX support"},{"location":"detection/#transform-an-algorithm","text":"To detect complex relations, Linnaeus provides a set of functions to transform an algorithm. permute(step) , returns a permutation of an algorithm with specific steps set by argument step . The default setting of step is 0, which returns the one-step permutation. step should be an integer and less than the total oracle number of the algorithm. conjugate(conjugate_oracle) , returns the conjugate of an algorithm with respect to the specific oracle set by argument conjugate_oracle . The default setting of conjugate_oracle is 0, which returns the conjugate with respect to the first oracle. conjugate_oracle should be an integer and within the set of oracle indices of the algorithm. If an algorithm contains n oracles, its set of oracle indices is [0, ..., n - 1] . dual() , returns the conjugate of an algorithm with respect to all the oracles. repeat(number) , returns a repetition of an algorithm that repeats the algorithm with number of times. The default setting of number is 2, which repeats the algorithm twice.","title":"Transform an algorithm"},{"location":"detection/#commutative-property","text":"Conjugation of different oracles commutes. Conjugation and permutation also commute. The following code transforms new_algo in different ways. new_algo.permute() new_algo.conjugate(1) new_algo.dual() new_algo.repeat(3) Here is an example demonstrating how to detect complex relations between algorithms using algorithm transformations.","title":"Commutative property"},{"location":"examples/","text":"Examples Check permutation algo5 algo6 import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) algo5.add_update(x1, proxf(x3)) algo5.add_update(x2, proxg(2*x1 - x3)) algo5.add_update(x3, x3 + x2 - x1) algo6 = Algorithm( algo6 ) xi1, xi2 = algo6.add_var( xi1 , xi2 ) proxf, proxg = algo6.add_oracle( proxf , proxg ) algo6.add_update(xi1, proxg(-xi1 + 2*xi2) + xi1 - xi2) algo6.add_update(xi2, proxf(xi1)) algo5.parse() algo6.parse() lin.is_permutation(algo5, algo6) System returns True Check repetition algo7 algo8 algo7 = Algorithm( algo7 ) t = algo7.add_parameter( t ) x1 = algo7.add_var( x1 ) f = algo7.add_function( f ) algo7.add_update(x1, x1 - t*lin.grad(f)(x1)) algo8 = Algorithm( algo8 ) xi1, xi2 = algo8.add_var( xi1 , xi2 ) t = algo8.add_parameter( t ) f = algo8.add_function( f ) algo8.add_update(xi2, xi1 - t*lin.grad(f)(xi1)) algo8.add_update(xi1, xi2 - t*lin.grad(f)(xi2)) algo7.parse() algo8.parse() lin.is_repetition(algo7, algo8) System returns True Check conjugation and permutation (Douglas-Rachford splitting and ADMM) For problem, Douglas-Rachford splitting ADMM DR = Algorithm( Douglas-Rachford splitting ) x1, x2, x3 = DR.add_var( x1 , x2 , x3 ) t = DR.add_parameter( t ) f, g = DR.add_function( f , g ) DR.add_update(x1, lin.prox(f, t)(x3)) DR.add_update(x2, lin.prox(g, t)(2*x1 - x3)) DR.add_update(x3, x3 + x2 - x1) ADMM = Algorithm( ADMM ) f, g = ADMM.add_function( f , g ) rho = ADMM.add_parameter( rho ) xi1, xi2, xi3 = ADMM.add_var( xi1 , xi2 , xi3 ) ADMM.add_update(xi1, lin.argmin(xi1, g(xi1) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi2, lin.argmin(xi2, f(xi2) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi3, xi3 + xi1 + xi2) DR.parse() ADMM.parse() # get a permutation of DR test_algo = DR.permute() lin.test_duality(test_algo, ADMM) Check conjugation (Douglas-Rachdford splitting and Chambolle-Pock method) Chambolle-Pock method CP = Algorithm( Chambolle-Pock method ) f, g = CP.add_function( f , g ) x1, x2, x3 = CP.add_var( x1 , x2 , x3 ) tau, sigma = CP.add_parameter( tau , sigma ) CP.add_update(x3, x1) CP.add_update(x1, lin.prox(f, tau)(x1 - tau*x2)) CP.add_update(x2, lin.prox(g, sigma)(x2 + sigma*(2*x1 - x3))) CP.parse() lin.test_conjugation(DR, CP)","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#check-permutation","text":"algo5 algo6 import linnaeus as lin from linnaeus import Algorithm algo5 = Algorithm( algo5 ) x1, x2, x3 = algo3.add_var( x1 , x2 , x3 ) proxf, proxg = algo3.add_oracle( proxf , proxg ) algo5.add_update(x1, proxf(x3)) algo5.add_update(x2, proxg(2*x1 - x3)) algo5.add_update(x3, x3 + x2 - x1) algo6 = Algorithm( algo6 ) xi1, xi2 = algo6.add_var( xi1 , xi2 ) proxf, proxg = algo6.add_oracle( proxf , proxg ) algo6.add_update(xi1, proxg(-xi1 + 2*xi2) + xi1 - xi2) algo6.add_update(xi2, proxf(xi1)) algo5.parse() algo6.parse() lin.is_permutation(algo5, algo6) System returns True","title":"Check permutation"},{"location":"examples/#check-repetition","text":"algo7 algo8 algo7 = Algorithm( algo7 ) t = algo7.add_parameter( t ) x1 = algo7.add_var( x1 ) f = algo7.add_function( f ) algo7.add_update(x1, x1 - t*lin.grad(f)(x1)) algo8 = Algorithm( algo8 ) xi1, xi2 = algo8.add_var( xi1 , xi2 ) t = algo8.add_parameter( t ) f = algo8.add_function( f ) algo8.add_update(xi2, xi1 - t*lin.grad(f)(xi1)) algo8.add_update(xi1, xi2 - t*lin.grad(f)(xi2)) algo7.parse() algo8.parse() lin.is_repetition(algo7, algo8) System returns True","title":"Check repetition"},{"location":"examples/#check-conjugation-and-permutation-douglas-rachford-splitting-and-admm","text":"For problem, Douglas-Rachford splitting ADMM DR = Algorithm( Douglas-Rachford splitting ) x1, x2, x3 = DR.add_var( x1 , x2 , x3 ) t = DR.add_parameter( t ) f, g = DR.add_function( f , g ) DR.add_update(x1, lin.prox(f, t)(x3)) DR.add_update(x2, lin.prox(g, t)(2*x1 - x3)) DR.add_update(x3, x3 + x2 - x1) ADMM = Algorithm( ADMM ) f, g = ADMM.add_function( f , g ) rho = ADMM.add_parameter( rho ) xi1, xi2, xi3 = ADMM.add_var( xi1 , xi2 , xi3 ) ADMM.add_update(xi1, lin.argmin(xi1, g(xi1) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi2, lin.argmin(xi2, f(xi2) + 1/2*rho*lin.norm_square(xi1 + xi2 + xi3))) ADMM.add_update(xi3, xi3 + xi1 + xi2) DR.parse() ADMM.parse() # get a permutation of DR test_algo = DR.permute() lin.test_duality(test_algo, ADMM)","title":"Check conjugation and permutation (Douglas-Rachford splitting and ADMM)"},{"location":"examples/#check-conjugation-douglas-rachdford-splitting-and-chambolle-pock-method","text":"Chambolle-Pock method CP = Algorithm( Chambolle-Pock method ) f, g = CP.add_function( f , g ) x1, x2, x3 = CP.add_var( x1 , x2 , x3 ) tau, sigma = CP.add_parameter( tau , sigma ) CP.add_update(x3, x1) CP.add_update(x1, lin.prox(f, tau)(x1 - tau*x2)) CP.add_update(x2, lin.prox(g, sigma)(x2 + sigma*(2*x1 - x3))) CP.parse() lin.test_conjugation(DR, CP)","title":"Check conjugation (Douglas-Rachdford splitting and Chambolle-Pock method)"},{"location":"quick_tutorial/","text":"Quick Tutorial In this quick tutorial, we define two algorithms and show that they are oracle-equivalent. The first algorithm, Import linnaeus and Algorithm class, import linnaeus as lin from linnaeus import Algorithm Define the first algorithm as algo1 with name Algoritm 1 , algo1 = Algorithm( Algorithm 1 ) Add variables x1 , x2 , and x3 to algo1 , x1, x2, x3 = algo1.add_var( x1 , x2 , x3 ) Add oracle gradf , gradient of f to algo1 , gradf = algo1.add_oracle( gradf ) Add update equations: # x3 - 2x1 - x2 algo1.add_update(x3, 2*x1 - x2) # x2 - x1 algo1.add_update(x2, x1) # x1 - x3 - 1/10*gradf(x3) algo1.add_update(x1, x3 - 1/10*gradf(x3)) Parse algo1 : algo1.parse() System returns the state-space realization of algo1 , The second algorithm, Define the second algorithm as algo2 and parse it: algo2 = Algorithm( Algorithm 2 ) xi1 = algo2.add_var( xi1 ) gradf = algo2.add_oracle( gradf ) # xi3 - xi1 algo2.add_update(xi3, xi1) # xi1 - xi1 - xi2 - 1/5*gradf(xi1) algo2.add_update(xi1, xi1 - xi2 - 1/5*gradf(xi3)) # xi2 - xi2 + 1/10*gradf(xi3) algo2.add_update(xi2, xi2 + 1/10*gradf(xi3)) algo2.parse() System returns the state-space realization of algo2 , Check oracle equivalence : lin.is_equivalent(algo1, algo2) System returns True which shows that algo1 and algo2 are oracle-equivalent.","title":"Quick Tutorial"},{"location":"quick_tutorial/#quick-tutorial","text":"In this quick tutorial, we define two algorithms and show that they are oracle-equivalent. The first algorithm, Import linnaeus and Algorithm class, import linnaeus as lin from linnaeus import Algorithm Define the first algorithm as algo1 with name Algoritm 1 , algo1 = Algorithm( Algorithm 1 ) Add variables x1 , x2 , and x3 to algo1 , x1, x2, x3 = algo1.add_var( x1 , x2 , x3 ) Add oracle gradf , gradient of f to algo1 , gradf = algo1.add_oracle( gradf ) Add update equations: # x3 - 2x1 - x2 algo1.add_update(x3, 2*x1 - x2) # x2 - x1 algo1.add_update(x2, x1) # x1 - x3 - 1/10*gradf(x3) algo1.add_update(x1, x3 - 1/10*gradf(x3)) Parse algo1 : algo1.parse() System returns the state-space realization of algo1 , The second algorithm, Define the second algorithm as algo2 and parse it: algo2 = Algorithm( Algorithm 2 ) xi1 = algo2.add_var( xi1 ) gradf = algo2.add_oracle( gradf ) # xi3 - xi1 algo2.add_update(xi3, xi1) # xi1 - xi1 - xi2 - 1/5*gradf(xi1) algo2.add_update(xi1, xi1 - xi2 - 1/5*gradf(xi3)) # xi2 - xi2 + 1/10*gradf(xi3) algo2.add_update(xi2, xi2 + 1/10*gradf(xi3)) algo2.parse() System returns the state-space realization of algo2 , Check oracle equivalence : lin.is_equivalent(algo1, algo2) System returns True which shows that algo1 and algo2 are oracle-equivalent.","title":"Quick Tutorial"}]}